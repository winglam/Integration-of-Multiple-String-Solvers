\section{approach}
\label{sec:approach}

\subsection{Overview Design of \imss}

\begin{figure}
    \centering
    \includegraphics[scale=0.45]{imss}
    \caption{\label{fig:imss}Schematic view of the \imss.}
\end{figure}

\begin{Grammar}
    \setlength{\grammarindent}{5em} % increase separation between LHS/RHS
    \begin{grammar}
        <Input> ::= <Statement>*                    \hfill \imss input

        <Statement> ::= String(<ID>)                \hfill string
                \alt Int(<ID>)                      \hfill int
                \alt StringDecl(<ID>, <STR_LIT>)    \hfill string witn value
                \alt Regex(<ID>, <RegStm>)          \hfill regex lang.
                \alt CFG(<ID>, <CFGStm>)            \hfill CFG lang.
                \alt <AssertStm>                    \hfill assert statement

        <RegStm> ::= <STR_LIT>                      \hfill string literal
                \alt <ID>                           \hfill variable name
                \alt Fix(<ID>, <INT_LIT>)           \hfill CFG fixed-sizing
                \alt Or(<RegStm>*)                  \hfill union
                \alt Concat(<RegStm>*)              \hfill concatenation
                \alt Star(<RegStm>)                 \hfill Kleene star

        <AssertStm> ::= AssertIn(<ID>,<ID>)         \hfill membership
                \alt Equal(<Exp>,<Exp>)             \hfill string equality
                \alt Contains(<StrExp>,<StrExp>)    \hfill string contains

        <Exp> ::= <IntExp>                          \hfill integer expression
                \alt <StrExp>                       \hfill string expression
                \alt <RegExp>                       \hfill regex expression
                \alt <ID>                           \hfill variable name

    \end{grammar}
 \caption{\label{fig:grammar}Summary of \imss's input language, shown in BNF grammars.
 Non-terminals are shown in angel brackets. \imss input consists of a list of statements.
 Statements can be variable declaration statements or assertion statements which represent
 constraints.}
 \end{Grammar}

\imss finds a string that satisfies constraints specified in the input,
or decides that no satisfying string exists. \imss utilizes three different
string solvers: \hampi, \dprle, \zstr to solve string
constraints. Overally, \imss works in the following four steps (Figure~\ref{fig:imss}):
\begin{enumerate}
    \item Parse the input constraints into an abstract syntax tree (AST)
    representation of the \imss language.
    \item Translate the AST into three input formats of the tree different solvers.
    \item Execute all the three solvers in parallel.
    \item Gather all the results. If none of the solvers can solve the constraints
    specified in the input, report that the constraints are incompatitble.
\end{enumerate}
The input format to \imss is specified by the grammar in Grammar~\ref{fig:grammar}.

\subsection{Example}

In order to demonstrate the four steps in \imss, let's consider an example of a input constraint
below:
\renewcommand\lstlistingname{Code}
\begin{lstlisting}[label={code:example},frame=bt,numbers=none,basicstyle=\ttfamily\scriptsize,
language=C,captionpos=b,caption={Input constraint in \imss format}]
1.  String(v);
2.  RangedLength(v, 1, 100);
3.  Contains(v, "abc");
5.  Regex(r, Star(Or("ab", "cd")))
6.  Contains(v, "deg");
7.  AssertIn(v, r);
6.  SolveAll();
\end{lstlisting}
This is a constraint to solve for a string that contains the substring $abc$, and
the string is a member of a regular expression, $(ab|cd)*$.
One of the strings which satisfy this constraint is ``abcd''. The string can be of any length
between 1 and 100. \imss will parse the input into an AST (Figure~\ref{fig:exp-ast}) according to Grammar~\ref{fig:grammar}.

\begin{figure*}
    \centering
    \includegraphics[scale=0.65]{example-ast}
    \caption{\label{fig:exp-ast}Abstract syntax tree of the example Code~\ref{code:example}.}
\end{figure*}

Then, \imss will translate the AST into all the three input formats by traversing the tree and
translate each tree node into a string format of each language. If a solver language does not support
some functionality (\imss cannot translate some node into that specific language),
the translation to that language will fail. If all the three translation fail, \imss
reports ``incompatible''. After that, \imss executes all the generated input formats on the
corresponding solvers in parallel and reports the solution.
