\section{background}
\label{sec:background}
\ping{TODO: add intro paragraph - in order to}


\subsection{\hampi, \dprle, and \zstr}
\imss combines three different solvers, \hampi, \dprle, and \zstr in order to gain more
language expressiveness and solve various kinds of constraints.

\hampi is a string constraint solver over fixed-size string variables. \hampi constraints can express
membership and may contain context-free language definition, strings, regular-language
definitions~\cite{hampi2009}. Even though \hampi is a string solver over fixed-size string variables,
users can specify a range of lengths to \hampi, and \hampi will try all the lengths in the given range
and output the shortest string that satisfies the constraints.

\dprle is a decision procedure that solves constraints over regular languages. The regular languages
in \dprle are represented in forms of finite state automata. \dprle constraints can express
membership and concatenation of regular languages~\cite{dprle2009}.

\zstr, an extension of Z3 SMT solver, is a string constraint solver that treats strings
as a primitive type and also supports booleans, integers, and string constants.
\zstr constraint can express variety of functionality such as concatenation, substring,
indexof, and replace~\cite{z32013}.

Given a set of constraints, these three string solvers will output a string that satisfies the given constraints, or reports that it is unsatisfiable.

\subsection{Abstract Syntax Tree}
Compilers typically consist of five main steps: lexical analysis, syntactic analysis, semantic
analysis, code generation, optimization. Lexical analysis parses a source code which contains
a sequence of characters into a sequence of tokens. Then syntactic analysis will build a
Abstract Syntax Tree (AST) from the sequence of tokens. AST is used to represent the structure
of a program. Each node of the tree denotes a statement or an expression in the source code.
The AST of a source code will be passed to the next step, semantic analysis.
Semantic analysis, code generation, and optimization will do semantic checking, such as type checking,
then generate a machine code instructions in the end. Our tool, \imss, contains only the first two steps.
The tool does not do any type checking nor code generation (\imss takes a input constraint which can be
viewed as a source code). The first two steps gives us an AST.
Later, we translate this AST (which captures all information of the source code) into three input formats
for the three solvers.

\subsection{Statistics for number of tests for each solver}
\begin{figure}[H]
    \centering
    \begin{tabular}{|l|r|r|r|l|}
        %\toprule
        \hline
        \textbf{Constraint solver} & \textbf{LOC} & \textbf{Tests} & \textbf{Version} \\
        \hline
        \dprle & 2992 & 16 & 0.5.0\\
        \hampi & 14197 & 379 & 20120213\\
        \zstr & 8616 & 245 & 1.0.0\\
        \hline
    \end{tabular}
    \caption{Constraint solvers supported by \imss.
        Column ``LOC'' represents the number of lines in the constraint solver's source code.
        Column ``Tests'' represents the number of tests provided by the developers of
        the constraint solvers.
    }
    \label{tab:solvers}
\end{figure}
